<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Bharath M R</title><link href="www.catchmrbharath.in/" rel="alternate"></link><link href="www.catchmrbharath.in/feeds/Programming.atom.xml" rel="self"></link><id>www.catchmrbharath.in/</id><updated>2012-08-19T00:00:00+05:30</updated><entry><title>GSoC last week</title><link href="www.catchmrbharath.in/posts/Programming/2012-Aug-19/gsoc-last-week/" rel="alternate"></link><updated>2012-08-19T00:00:00+05:30</updated><author><name>Bharath M R</name></author><id>tag:www.catchmrbharath.in,2012-08-19:posts/Programming/2012-Aug-19/gsoc-last-week/</id><summary type="html">&lt;p&gt;This happens to be the last week of GSoC. The major things that I accomplished this
week are&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Got pylab to work interactively.&lt;/li&gt;
&lt;li&gt;Made more changes to the documentation of plotting module. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I have a pull request for the restructured plotting module at &lt;a href="https://github.com/sympy/sympy/pull/1468"&gt;here&lt;/a&gt;.
There has been lots of discussions on how the new plot API should look like in the pull request.
The API as of now has 5 functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;plot_line&lt;/code&gt; which plots 2D line plots, which I think I will change to &lt;code&gt;plot&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;plot_parametric&lt;/code&gt; which plots 2D parametric plots.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;plot3D&lt;/code&gt; which plots 3D plots.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;plot3D_parametric&lt;/code&gt; which plots 3D parametric line plots. I think I will have to 
change it into &lt;code&gt;plot_parametric3D&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;plot3D_surface&lt;/code&gt; which plots 3D parametric surfaces.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The names are slightly confusing, but the alternative to these names are big. If you
have any good names for 3D plots, please leave it in the comments.&lt;/p&gt;
&lt;p&gt;I will have another post describing the things I learnt over this GSoC period.&lt;/p&gt;</summary><category term="[gsoc]"></category></entry><entry><title>GSOC week 11</title><link href="www.catchmrbharath.in/posts/Programming/2012-Aug-05/gsoc-week-11/" rel="alternate"></link><updated>2012-08-05T00:00:00+05:30</updated><author><name>Bharath M R</name></author><id>tag:www.catchmrbharath.in,2012-08-05:posts/Programming/2012-Aug-05/gsoc-week-11/</id><summary type="html">&lt;p&gt;I got my adaptive sampling branch merged last week. Now the plots are sampled
adaptively and is more accurate. I also added a lot of tests to the implicit plotting
branch and the coverage now is greater than 90%. &lt;/p&gt;
&lt;p&gt;One of the major things decided in the previous week was to restructure the plot
function. Presently &lt;code&gt;plot&lt;/code&gt; is a single function, which depending on its input, renders
an 2d or an 3d plot. Though it plots the right kind of plot, the &lt;code&gt;plot&lt;/code&gt; function is
quite complex and it was decided to split the plot function into smaller functions
that plots a particular type of plot. I tried an approach where all 2D plots are plotted
by a &lt;code&gt;plot2d&lt;/code&gt; function, the 3D plots by &lt;code&gt;plot3D&lt;/code&gt; and the existing &lt;code&gt;plot_implicit&lt;/code&gt; 
plots to plot regions and implicit equations. Aaron mentioned that the API is still very
complex as I was using tuples and lists to differentiate between a parametric plot
and a 2d line plot and he was right. It is a bit complex and it was decided to have
a functions for each kind of plot. &lt;/p&gt;
&lt;p&gt;I think i can have the new plot functions as an PR by next week and I would like to
try getting a Mayavi backend ready by the end of my GSoC period.&lt;/p&gt;
&lt;p&gt;I forgot to mention why I deviated from my what I said I would do in my GSoC
application. I tried getting a svgfig backend ready for almost one and a half week,
and it was quite difficult. svgfig is not being updated and I had a hard time getting
the axis ticks labelling to work most of the time. I wrote to the project maintainer
many times and he helped me with a lot of things, but the library was not polished
enough to use it with Sympy Live. So plotting for SymPy Live should be attempted
with a javascript plotting library rather than a python backend. If we get matplotlib
support on GAE, then it would be awesome.&lt;/p&gt;</summary><category term="[gsoc]"></category></entry><entry><title>Gsoc week 9</title><link href="www.catchmrbharath.in/posts/Programming/2012-Jul-23/gsoc-week-9/" rel="alternate"></link><updated>2012-07-23T00:00:00+05:30</updated><author><name>Bharath M R</name></author><id>tag:www.catchmrbharath.in,2012-07-23:posts/Programming/2012-Jul-23/gsoc-week-9/</id><summary type="html">&lt;p&gt;This has been a really unproductive week. I was sick with fever for almost three
days and could not spend my time on anything. I spent the next days getting the 
basic svgfig backend for 2d line plots. There are lots of issues with svgfig, and
hence I am of the opinion svgfig should be used only for displaying images on the
google app engine ie sympy live. First on the list is no support for 3-D graphs. I think this is 
ok, because there are not many libraries even in javascript which can do 3D plotting.
Also, I am having problems with implementing contour plots and surface plots in
svgfig. I am experimenting with a way, which would involve using marching squares
algorithm to plot contour plots.&lt;/p&gt;
&lt;p&gt;I think I am a little behind my gsoc schedule, and I should speed up things a little
in the next few weeks.&lt;/p&gt;
&lt;p&gt;So these are the things that I have to address&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Integration of svgfig with sympy live&lt;/li&gt;
&lt;li&gt;Fix the multiple spawning of windows in matplotlib issue.&lt;/li&gt;
&lt;li&gt;Fix the plot tests. As of now, the tests do nothing, as the process_series is not called if show is set to False.&lt;/li&gt;
&lt;li&gt;I have been toying around with ipython to get isympy notebook and qtconsole working. The problem I am facing is, there are 2 instances of qtconsole created, instead of one, when I run it. I will have to figure out the problem.&lt;/li&gt;
&lt;li&gt;Address the issues regarding the adaptive sampling of 2d plots.&lt;/li&gt;
&lt;li&gt;Clean up my branch of implicit plotting (This is almost done).&lt;/li&gt;
&lt;li&gt;Split the plot function into plot, plot3d, implicit_plot functions.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I don't think I will be able to do all of these by the end of gsoc period. But my priority will be getting the implicit plotting and svgfig backend working and getting my pull requests merged.&lt;/p&gt;</summary><category term="[gsoc]"></category></entry><entry><title>GSoC week 7</title><link href="www.catchmrbharath.in/posts/Programming/2012-Jul-09/gsoc-week-7/" rel="alternate"></link><updated>2012-07-09T00:00:00+05:30</updated><author><name>Bharath M R</name></author><id>tag:www.catchmrbharath.in,2012-07-09:posts/Programming/2012-Jul-09/gsoc-week-7/</id><summary type="html">&lt;p&gt;This week has been quite eventful. The implicit plotting module is almost done. I added the functionality of combining expressions using the &lt;code&gt;And&lt;/code&gt; and &lt;code&gt;Or&lt;/code&gt; statements. Now you can do
&lt;code&gt;plot_implicit(And(Eq(y, exp(x)), y - x &amp;gt; 2)&lt;/code&gt;
and get a plot as below. So now you can combine any number of equations / inequalities and plot it. I think its possible to do a lot of cool stuff combining equations / inequalities.
&lt;img src="/images/09072012/fig1.png" width="600" height= "400" /&gt;&lt;/p&gt;
&lt;p&gt;Plotting through interval math is awesome but is also very limited. You cannot add support to &lt;code&gt;re()&lt;/code&gt;, to functions that you cannot characterize as monotonic in certain regions. But we always encounter such functions. So there should be some fall back algorithm to plot such plots. I implemented the fall back algorithm last week. The idea is borrowed from sage implicit plots. We convert an equation / inequality into a function which returns 1 if it satisfies and -1 if it doesn't satisfy. So if you are plotting an equality then you plot using the &lt;code&gt;contour&lt;/code&gt; command of matplotlib, and instruct it to plot only the zero contour. If its an inequality then plotting the region with two colors gives the plot required. &lt;/p&gt;
&lt;p&gt;These are examples from the fallback algorithm.&lt;/p&gt;
&lt;p&gt;Plot of &lt;mathjax&gt;$y^{2}=x^{3}-x$&lt;/mathjax&gt;
&lt;img src="/images/09072012/fig2.png" width="600" height= "400" /&gt;&lt;/p&gt;
&lt;p&gt;The plot with interval arithmetic is more precise.
&lt;img src="/images/09072012/fig3.png" width="600" height= "400" /&gt;&lt;/p&gt;
&lt;p&gt;I haven't finished with the tests. Once I finish the tests I can send a pull request. The pull request will be pretty big, but most of the things have been reviewed in my previous pull request. This is just an extension of the previous pull request.&lt;/p&gt;
&lt;p&gt;There are certain problems with the module though. The line width problem which I mentioned in my previous blog post, cannot be fixed. So you will have to change to the fall back method if the line width becomes large. Also the fall back algorithm cannot plot boolean combinations of equations / inequalities. So the two methods complement each other largely. So the next question would be whether we can choose one of the two intelligently. I guess the answer is No. That decision must be taken by the user. But most of the times the interval math approach works very nicely. &lt;/p&gt;</summary><category term="[gsoc]"></category></entry><entry><title>GSoC Week 6</title><link href="www.catchmrbharath.in/posts/Programming/2012-Jul-02/gsoc-week-6/" rel="alternate"></link><updated>2012-07-02T00:00:00+05:30</updated><author><name>Bharath M R</name></author><id>tag:www.catchmrbharath.in,2012-07-02:posts/Programming/2012-Jul-02/gsoc-week-6/</id><summary type="html">&lt;p&gt;I have been trying to improve the implicit plotting module during this week. But I have hit a road block. I almost ran out of ideas to solve the problem.&lt;/p&gt;
&lt;p&gt;Description:&lt;/p&gt;
&lt;p&gt;The implicit plotting algorithm I implemented works something like below:&lt;/p&gt;
&lt;p&gt;1) Get x and y interval. If it satisfies the expression throughout the interval, then plot it.&lt;/p&gt;
&lt;p&gt;2) If it does not satisfy, throw away the intervals.&lt;/p&gt;
&lt;p&gt;3) If it partially satisfies, then recursively subdivide into four intervals, and try again.&lt;/p&gt;
&lt;p&gt;For cases of equality, the first point never holds true due to floating point errors. So we go on
eliminating regions, and after a certain depth, plot the remaining region. These are the regions where there is at least one solution. This is the reason why the plots are rasterized. But there is an inherent bigger problem here. In the cases of expressions like &lt;mathjax&gt;$x^{3}$&lt;/mathjax&gt; even if the x interval is small, the resulting interval after computation will be large. Sometimes, due to these large intervals, there might be lots of y and x intervals which satisfy because of these errors. Even if we make x interval really small, the corresponding y interval will be large, ie the line widths become large. The explanation is more of a guess rather than the right explanation.&lt;/p&gt;
&lt;p&gt;Examples:&lt;/p&gt;
&lt;p&gt;Plot of &lt;mathjax&gt;$x^{y}=y^{x}$&lt;/mathjax&gt;
&lt;img src="/images/02072012/fig1.png" width="600" height= "400" /&gt;
Even if I increase my depth of recursion to higher values, the thickness becomes less, but doesn't vanish. The plot actually should have been two separate curves.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/02072012/fig3.png" width="600" height= "400" /&gt;&lt;/p&gt;
&lt;p&gt;The Mac OSX's Grapher uses a similar algorithm(A guess because they have similar rasterization) but takes care of the line widths.&lt;/p&gt;
&lt;p&gt;If you feel you know where the problem is, please comment or email me. :)&lt;/p&gt;</summary><category term="[gsoc"></category><category term="plotting]"></category></entry><entry><title>Gsoc week 5</title><link href="www.catchmrbharath.in/posts/Programming/2012-Jun-24/gsoc-week-5/" rel="alternate"></link><updated>2012-06-24T00:00:00+05:30</updated><author><name>Bharath M R</name></author><id>tag:www.catchmrbharath.in,2012-06-24:posts/Programming/2012-Jun-24/gsoc-week-5/</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;This week has been mostly bug fixing and working on migrating the sympy ipython profile to sympy. I also wanted to add the functionality of &lt;code&gt;ipython -c qtconsole&lt;/code&gt;. So it has been mostly hanging in the ipython irc, asking them lots of questions on how ipython works. I am really thankful to minrk who patiently taught me how to do most of the stuff. There are a few problems that I am facing, but I think I will have the qtconsole ready in a day.&lt;/p&gt;
&lt;p&gt;I also submitted a pull request #1370 for my initial work on implicit plotting. Except for the bug of changing line thickness, it works pretty nicely. Please feel free to play with it and comment on the pull request if you encounter any bugs.&lt;/p&gt;</summary><category term="[gsoc]"></category></entry><entry><title>GSoC Week 3</title><link href="www.catchmrbharath.in/posts/Programming/2012-Jun-09/gsoc-week-3/" rel="alternate"></link><updated>2012-06-09T00:00:00+05:30</updated><author><name>Bharath M R</name></author><id>tag:www.catchmrbharath.in,2012-06-09:posts/Programming/2012-Jun-09/gsoc-week-3/</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;I have almost finished with the basic framework of implicit plotting based on interval arithmetic. The module implements both continuity tracking and domain tracking. Hence it does not plot points which are not there in the domain of the function. The functionalities are best illustrated by plots. There are also a couple of limitations that I encountered, which I think is difficult to avoid. I will illustrate both the functionality and the problems through plots.&lt;/p&gt;
&lt;p&gt;&lt;img src='/images/09062012/img1.png' width="600" height="400" /&gt;
The above image illustrates a plot which does domain tracking and continuity tracking. It is not possible for interval arithmetic without tracking, to decide whether to draw the plots near zero. But with continuity tracking we get an accurate plot.&lt;/p&gt;
&lt;p&gt;&lt;img src='/images/09062012/img2.png' width="600" height="400" /&gt;
The above plot is that of &lt;mathjax&gt;$y = \frac{1}{\tan{\left (x \right )}}$&lt;/mathjax&gt; . It is possible to see the small discontinuity near multiples of &lt;mathjax&gt;$\pi / 2$&lt;/mathjax&gt; as &lt;mathjax&gt;$\pi / 2$&lt;/mathjax&gt; is not there in the domain of the expression. &lt;/p&gt;
&lt;p&gt;&lt;img src='/images/09062012/img3.png' width="600" height="400" /&gt;
The above plot illustrates how sqrt does not plot anything outside its domain. Even though it appears not that significant, it becomes significant when the huge expression is provided as the argument to the function.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Illustrations of more plots&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Plot of &lt;mathjax&gt;$y^{2}=x^{3}-x$&lt;/mathjax&gt;
&lt;img src='/images/09062012/img4.png' width="600" height="400" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src='/images/09062012/img5.png' width="600" height="400" /&gt;
The above plot took 19.26 seconds to render.&lt;/p&gt;
&lt;h2&gt;Problems&lt;/h2&gt;
&lt;p&gt;The problem with plots using interval arithmetic is that the errors increases with the length of the expression as the it takes the lowest and the uppermost bounds. It is possible to see the effect of errors in the following plot. It is possible to see the line thickens when the expression reaches a maximum or an minimum. This is due to the error creeping in. The interval becomes wide even at the smallest of the x interval.&lt;/p&gt;
&lt;p&gt;&lt;img src='/images/09062012/img6.png' width="600" height="400" /&gt;&lt;/p&gt;
&lt;p&gt;It is better illustrated in the plot below. It is possible to see the width of the line increasing and then decreasing.
&lt;img src='/images/09062012/img7.png' width="600" height="400" /&gt;&lt;/p&gt;
&lt;p&gt;Then next problem is that of rasterization. In order to avoid rasterization I tried using the Matplotlib's &lt;code&gt;contourf&lt;/code&gt; function which implements the marching squares algorithm. Though it smoothens the curves, still there is fair bit of rasterization. The plot below is a zoomed version of &lt;mathjax&gt;$y=sin(x)$&lt;/mathjax&gt;
&lt;img src='/images/09062012/img8.png' width="600" height="400" /&gt;&lt;/p&gt;
&lt;p&gt;Presently the plotting function supports plotting of expressions containing &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;tan&lt;/code&gt;, &lt;code&gt;exp&lt;/code&gt;, &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;sqrt&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt;. Implementing more functions is fairly easy. I should be able to finish most of the expressions that can be implemented in the next week. I will look into implementing plotting implicit equations for expressions which cannot be implemented using interval arithmetic.&lt;/p&gt;</summary><category term="[gsoc]"></category></entry><entry><title>GSoC Week 2</title><link href="www.catchmrbharath.in/posts/Programming/2012-Jun-03/gsoc-week-2/" rel="alternate"></link><updated>2012-06-03T00:00:00+05:30</updated><author><name>Bharath M R</name></author><id>tag:www.catchmrbharath.in,2012-06-03:posts/Programming/2012-Jun-03/gsoc-week-2/</id><summary type="html">&lt;p&gt;I worked on interval aithmetic using numpy this week. I have almost got the module ready. I have to integrate it with Stefan's branch and a basic version of implicit plotting will be ready to go. I will update this blog post with plots and performance results once I integrate it with Stefan's branch.&lt;/p&gt;</summary><category term="[gsoc]"></category></entry><entry><title>Adaptive sampling for 2D plots</title><link href="www.catchmrbharath.in/posts/Programming/2012-May-26/adaptive-sampling-for-2d-plots/" rel="alternate"></link><updated>2012-05-26T00:00:00+05:30</updated><author><name>Bharath M R</name></author><id>tag:www.catchmrbharath.in,2012-05-26:posts/Programming/2012-May-26/adaptive-sampling-for-2d-plots/</id><summary type="html">&lt;p&gt;This was my first week of GSoC and I spent time on experimenting with adaptive sampling. The major idea explored were what constitutes a condition for which we need not sample more to obtain an accurate plot. I started with the idea of the area of the triangle formed by the three consecutive points to be 
less than a tolerance value. This worked nicely but did oversampling unnecessarily. The problem with it was the area of the triangle was dependent on the distance between the points which made the condition dependent on the lengths and hence oversampled even though the line formed by the three points was almost collinear.
So the obvious next idea was to check the angle formed by the three points and see whether it forms an angle near to 180 degree. There were three versions of the above algorithm implemented, out of which one was the iterative version of a recursive solution. The iterative version is &lt;a href="https://github.com/Krastanov/sympy/pull/5"&gt;here&lt;/a&gt;. Considering Stefan Krastanov's suggestion, I implemented a recursive solution which samples 5 additional points between two points instead of a single point. The idea was to use numpy's quick evaluations of an array and also arrive at the straight line condition faster. Also, this reuses most of the code written before. The code for the following can be found &lt;a href="https://github.com/catchmrbharath/sympy/tree/adaptnew"&gt;here&lt;/a&gt;. The snippet of the code is as follows:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get_adapt_segments&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vectorized_lambdify&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;list_segments&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;

        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;sample&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;segment&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;depth&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;depth&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;list_segments&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;segment&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;new_sampling&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;linspace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;segment&lt;/span&gt;&lt;span class="p"&gt;[:,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;new_segments&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_segments&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;new_sampling&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_sampling&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;segmentA&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;segmentB&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;zip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_segments&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;new_segments&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:]):&lt;/span&gt;
                    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;flat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;segmentA&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;segmentB&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                        &lt;span class="n"&gt;sample&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;segmentA&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;depth&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                        &lt;span class="n"&gt;list_segments&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;segmentA&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="c"&gt;#sample the last segment&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;flat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_segments&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;new_segments&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]):&lt;/span&gt;
                    &lt;span class="n"&gt;sample&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_segments&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;depth&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;list_segments&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_segments&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

        &lt;span class="n"&gt;points&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;linspace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;yvalues&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;points&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;segments&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_segments&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;points&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;yvalues&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;segment&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;segments&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;sample&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;segment&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;list_segments&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;flat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;segmentA&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;segmentB&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;vectorA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;segmentA&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;segmentA&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;vectorB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;segmentB&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;segmentB&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;costheta&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vectorA&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vectorB&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;linalg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;norm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vectorA&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;linalg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;norm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vectorB&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;costheta&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mf"&gt;0.0005&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The major problem with the above approach is the way that the rightmost point / segment is handled. The rightmost segment does not have another right segment to decide whether it forms a 180 degree angle or not. Hence it is assumed straight if the previous segment and the present segment forms a straight line. Most of the time this fails to sample further for the end segment thought it should have sampled. The problem can be seen in an plot of &lt;span&gt; &lt;mathjax&gt;$y = sin(x^{2})$&lt;/mathjax&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/26052012/plot.png" width="600" height= "400" /&gt;&lt;/p&gt;
&lt;p&gt;The last method used is symmetric and gives better results, but it is quite ugly. The branch is &lt;a href="https://github.com/catchmrbharath/sympy/tree/complexplot"&gt;here&lt;/a&gt;.(EDIT: changed the link). It uses some amount of random sampling to avoid aliased results. The plot of &lt;span&gt; &lt;mathjax&gt;$y = sin(x^{2})$&lt;/mathjax&gt; &lt;/span&gt; renders very accurately. Feel free to experiment with it and if there is a better method, you can comment below :).&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/26052012/betterplot.png" width="600" height= "400" /&gt;&lt;/p&gt;
&lt;p&gt;I think I will get an non - ugly code ready by the tomorrow and wait for Stefan's branch to get merged before submitting this method as pull request. This week has been lots of experimentation. I think I will spend the next week getting a basic version of Interval Arithmetic ready using numpy.&lt;/p&gt;</summary><category term="[gsoc]"></category></entry><entry><title>Region Plots with Interval Arithmetic</title><link href="www.catchmrbharath.in/posts/Programming/2012-May-14/region-plots-with-interval-arithmetic/" rel="alternate"></link><updated>2012-05-14T00:00:00+05:30</updated><author><name>Bharath M R</name></author><id>tag:www.catchmrbharath.in,2012-05-14:posts/Programming/2012-May-14/region-plots-with-interval-arithmetic/</id><summary type="html">&lt;p&gt;My GSoC project is to provide support for implicit plotting using interval arithmetic. As mpmath already has a very good interval arithmetic library, I wanted to try out how efficient the algorithm is going to be using the mpmath interval arithmetic library. I wanted to get an idea on the time required for plotting and also wanted to decide whether to write my own interval arithmetic library or use the existing mpmath library and add additional things to it. 
I have a basic implementation which supports only the mpmath interval arithmetic functions. The results look promising and I am guessing a separate implementation for plotting will be faster and I will be able to add features more easily.I have an image of &lt;span&gt; &lt;mathjax&gt;$y &amp;gt; 1/x$&lt;/mathjax&gt; &lt;/span&gt; with the interval edges below. The image below was plotted so with a resolution of 1024x1024. It is possible to see how the intervals are subdivided more and more when it reaches the edge of a region. &lt;/p&gt;
&lt;p&gt;&lt;img src="/images/14052012/figwithedge.png" width="600" height= "400" /&gt;&lt;/p&gt;
&lt;p&gt;It took 1.57 seconds to render this image which is decently fast. I observed that if the independent regions are less and large, then the time take for the plot to be rendered is high. I tried &lt;span&gt; &lt;mathjax&gt;$cos(y) &amp;gt; sin(x)$&lt;/mathjax&gt; &lt;/span&gt; which took about 5.3 seconds to render. &lt;/p&gt;
&lt;p&gt;&lt;img src="/images/14052012/cosysinx.png" width="600" height= "400" /&gt;&lt;/p&gt;
&lt;p&gt;I wanted to try what the maximum time it takes to render something. So I tried plotting &lt;span&gt; &lt;mathjax&gt;$sin^{2}x+cos^{2}x$&lt;/mathjax&gt; &lt;/span&gt;less than 1. As the arithmetic is done on intervals, it is not possible for the algorithm to decide that the expression is not true throughout the interval. So it goes on subdividing more and more, until it reaches a dimension of 1 pixel. For a resolution of 512X512, it took 120 seconds to render. If there are a lot of evaluations in the expression, then it might increase, but we should be expecting times around 120 seconds. &lt;/p&gt;
&lt;p&gt;Another problem that I have to address is rasterization. I am really not getting any ideas on how to avoid rasterization. One way is to handle the zoom event in matplotlib and change the data to match the zoom. But for complicated graphs, revaluating might take a lot of time, which is bad. &lt;/p&gt;
&lt;p&gt;&lt;img src="/images/14052012/figraster.png" width="600" height= "400" /&gt;&lt;/p&gt;
&lt;p&gt;We can see that if there is a way of interpolating over the rectangular edges, then we will have a plot without rasterization. I haven't got any foolproof idea to implement this interpolation as there will be many independent regions. So if you have any idea, then please comment or mail me :). The code for plotting can be found &lt;a href="https://gist.github.com/2695079"&gt;here&lt;/a&gt;.&lt;/p&gt;</summary><category term="[gsoc"></category><category term="sympy]"></category></entry><entry><title>GSoC 2012 Sympy</title><link href="www.catchmrbharath.in/posts/Programming/2012-May-08/gsoc-2012-sympy/" rel="alternate"></link><updated>2012-05-08T00:00:00+05:30</updated><author><name>Bharath M R</name></author><id>tag:www.catchmrbharath.in,2012-05-08:posts/Programming/2012-May-08/gsoc-2012-sympy/</id><summary type="html">&lt;p&gt;I was selected by &lt;a href="http://sympy.org"&gt;SymPy&lt;/a&gt; to work on their plotting module as part of GSoC2012. So I will be spending the next three months working on a plotting module to plot implicit functions. Implicit functions are difficult to plot by simple meshing. Though we might get a good result with simple meshing for most of the functions, it can be quite erroneous for some of the functions. So I will be using interval arithmetic to provide a way to plot implicit functions. My GSoC application can be found &lt;a href="https://github.com/sympy/sympy/wiki/GSoC-2012-Application-Bharath-M-R%3A-Plotting-Module"&gt;here&lt;/a&gt;. I will be atlast making a lasting contribution to an open - source software.&lt;/p&gt;
&lt;p&gt;There are a lot of posts on how contributing to a open source software is the best way to sharpen your programming skills. But lot of people are too afraid to approach an organization and start contributing. There is an impending fear that people working on these projects are very stud(intelligent) people and they might get annoyed at your ignorance. Well, let me tell you this, people in an open source project are really nice. They don't get annoyed very easily and they are ready to help you with everything. They correct all your mistakes with lots of patience and help you with improving your code. I think getting your code reviewed is the best way to improve your programming skills after you have reached a certain stage. &lt;/p&gt;
&lt;p&gt;I was pretty much amazed with SymPy's code base. Its so neat and clean that any newcomer can just look at the docstrings and can deduce the functionality of every function. Though my experience is limited, I haven't seen a better codebase than SymPy's. I am still looking at their codebase and the amount of modularity continues to amaze me. So if anybody is interested in contributing to a python open source project, then consider contributing to &lt;a href="http://sympy.org"&gt;SymPy&lt;/a&gt;, for you will learn a lot on how a python project has to be structured.&lt;/p&gt;
&lt;p&gt;I will be using this blog to update about my GSoC project and hopefully I will learn a lot during this period.&lt;/p&gt;</summary><category term="[SymPy"></category><category term="GSoC]"></category></entry></feed>